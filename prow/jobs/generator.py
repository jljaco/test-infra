import argparse
import dataclasses
import os
import sys
from typing import Dict, Mapping
import yaml
from jinja2 import Environment, FileSystemLoader
from datetime import datetime

"""Script to auto-generate jobs.yaml and labels.yaml files
"""

# Load the config to be used with jinja templates.
config = yaml.safe_load(open('./jobs_config.yaml'))
image_config = yaml.safe_load(open('./images_config.yaml'))
env = Environment(loader=FileSystemLoader('./'), trim_blocks=True, lstrip_blocks=True)

@dataclasses.dataclass(frozen=True)
class ImageContext:
    image_repo: str
    images: Mapping[str, str] # Map from image name to image tag

def load_images(image_file_content: Dict) -> ImageContext:
    if "image_repo" not in image_file_content:
        raise ValueError("Key image_repo not found in images config")
    
    image_repo = image_file_content["image_repo"]
    images = {}
    for key in image_file_content["images"]:
        # Prepend image repo to each of the image tags
        images[key] = image_repo + ":" + image_file_content["images"][key]
    return ImageContext(image_repo=image_repo, images=images)

def load_templates(prow_job_type: str, template_dir: str) -> str:
    try:
        template_files = os.listdir(template_dir)

        if template_files is not None:
            template_files.sort()
    except FileNotFoundError as fe:
        print(f'{template_dir}: No such directory to load templates. Ignoring.')
        return ""

    image_context = load_images(image_config)

    content = f'{prow_job_type}:\n'
    for file_name in template_files:
        template_content = env.get_template(f'{template_dir}/{file_name}')
        rendered_content = template_content.render(config, image_context=image_context)
        content += f'{rendered_content}\n'

    return content

def generate_jobs(dst_path):
    jinja_path = './jinja'
    periodic_jobs_path = f'{jinja_path}/periodics'
    postsubmit_jobs_path = f'{jinja_path}/postsubmits'
    presubmit_jobs_path = f'{jinja_path}/presubmits'

    prowjobs_content = "# Autogenerated. Do NOT update Manually.\n"
    prowjobs_content += f'# Last generated on {datetime.now()}.\n'
    prowjobs_content += load_templates('periodics', periodic_jobs_path)
    prowjobs_content += load_templates('postsubmits', postsubmit_jobs_path)
    prowjobs_content += load_templates('presubmits', presubmit_jobs_path)

    with open(dst_path, 'w') as jobs_file:
        jobs_file.write(prowjobs_content)

def generate_label_sync_config(dst_path):
    jinja_path = './jinja'

    config_content = "# Autogenerated. Do NOT update Manually.\n"
    config_content += f'# Last generated on {datetime.now()}.\n#\n'
    template_content = env.get_template(f"{jinja_path}/config/label_sync.jinja2")
    config_content += template_content.render(config)

    with open(dst_path, 'w') as config_file:
        config_file.write(config_content)

def main():
    parser = argparse.ArgumentParser(description='Prow generator CLI tool')
    parser.add_argument('command', type=str, help='command to execute', default="jobs", choices=["jobs", "labels"])
    parser.add_argument('-o', '--output', help="output file path")
    args = parser.parse_args(sys.argv[1::])
    
    if args.command == "jobs":
        generate_jobs(args.output)
    elif args.command == "labels":
        generate_label_sync_config(args.output)

if __name__ == "__main__":
    main()